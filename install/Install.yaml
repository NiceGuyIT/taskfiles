---
version: "3"

vars:
  SOFTWARE_LIST: |
    age
    age-keygen
    alacritty
    atuin
    cfssl-certinfo
    fd
    fzf
    lego
    ouch
    rclone
    ripgrep
    sops
    starship

tasks:

  general:
    desc: Download and install packages
    summary: |
      Download and install packages.
    preconditions:
      - sh: '[ ! -z {{ quote .NAME }} ]'
        msg: NAME {{ quote .NAME }} is not defined. Please specify the package NAME as an ENV var.
    vars:
      FILE: 'install/packages/packages.yaml'
      # Name is the binary package to install, not the repo name or actual package name.
      NAME: '{{.NAME | default "unknown" }}'
      PKG_PROVIDER:
        sh: |
          [ {{ quote .NAME }} == "unknown" ] && echo "Name was not provided" && exit 1
          provider=$(yq --output-format json --unwrapScalar '.packages.{{.NAME}}.provider' {{.FILE}})
          if [ "${provider}" == 'null' ]; then
            echo "Package provider '${provider}' not defined in YAML" && exit 1
          else
            echo "${provider}"
          fi
      PKG_REPO_NAME:
        sh: |
          [ {{ quote .NAME }} == "unknown" ] && echo "Name was not provided" && exit 1
          repo=$(yq --output-format json --unwrapScalar '.packages.{{.NAME}}.{{.PKG_PROVIDER}}.repo' {{.FILE}})
          if [ "${repo}" == 'null' ]; then
            echo "Package provider.repo '${repo}' not defined in YAML" && exit 1
          else
            echo "${repo}"
          fi
      PKG_REPO_OWNER:
        sh: |
          [ {{ quote .NAME }} == "unknown" ] && echo "Name was not provided" && exit 1
          owner=$(yq --output-format json --unwrapScalar '.packages.{{.NAME}}.{{.PKG_PROVIDER}}.owner' {{.FILE}})
          if [ "${owner}" == 'null' ]; then
            echo "Package provider.owner '${owner}' not defined in YAML" && exit 1
          else
            echo "${owner}"
          fi
      PKG_ARCH:
        sh: |
          [ {{ quote .NAME }} == "unknown" ] && echo "Name was not provided" && exit 1
          arch=$(yq --output-format json --unwrapScalar '.packages.{{.NAME}}.arch.{{ARCH}}' {{.FILE}})
          if [ "${arch}" == 'null' ]; then
            echo "{{ARCH}}"
          else
            echo "${arch}"
          fi
      PKG_OS:
        sh: |
          [ {{ quote .NAME }} == "unknown" ] && echo "Name was not provided" && exit 1
          os=$(yq --output-format json --unwrapScalar '.packages.{{.NAME}}.os.{{OS}}' {{.FILE}})
          if [ "${os}" == 'null' ]; then
            echo "{{OS}}"
          else
            echo "${os}"
          fi
      # Does the archive have a directory?
      PKG_ARCHIVE_DIR:
        sh: |
          [ {{ quote .NAME }} == "unknown" ] && echo "Name was not provided" && exit 1
          archive_dir=$(yq --output-format json --unwrapScalar '.packages.{{.NAME}}.archive.dir' {{.FILE}})
          if [ "${archive_dir}" == 'null' ]; then
            # pkg_archive_dir is not required
            echo ""
          else
            echo "${archive_dir}"
          fi
      # Archive directory name: PKG_ARCHIVE_DIR_NAME/PKG_ARCHIVE_FILE_NAME
      PKG_ARCHIVE_DIR_NAME:
        sh: |
          [ {{ quote .NAME }} == "unknown" ] && echo "Name was not provided" && exit 1
          archive_dir_name=$(yq --output-format json --unwrapScalar '.packages.{{.NAME}}.archive.dir_name' {{.FILE}})
          if [ "${archive_dir_name}" == 'null' ]; then
            # Default is same as repo name.
            echo "{{.PKG_REPO}}"
          else
            echo "${archive_dir_name}"
          fi
      # Archive file name: PKG_ARCHIVE_DIR_NAME/PKG_ARCHIVE_FILE_NAME
      PKG_ARCHIVE_FILE_NAME:
        sh: |
          [ {{ quote .NAME }} == "unknown" ] && echo "Name was not provided" && exit 1
          archive_file_name=$(yq --output-format json --unwrapScalar '.packages.{{.NAME}}.archive.file_name' {{.FILE}})
          if [ "${archive_file_name}" == 'null' ]; then
            # Default is same as repo name.
            echo "{{.PKG_REPO}}"
          else
            echo "${archive_file_name}"
          fi
      # Archive extension
      PKG_ARCHIVE_EXT:
        sh: |
          [ {{ quote .NAME }} == "unknown" ] && echo "Name was not provided" && exit 1
          archive_ext=$(yq --output-format json --unwrapScalar '.packages.{{.NAME}}.archive.ext.{{OS}}' {{.FILE}})
          if [ "${archive_ext}" == 'null' ]; then
            default=$(yq --output-format json --unwrapScalar '.packages.{{.NAME}}.archive.ext.default' {{.FILE}})
            if [ "${default}" == 'null' ]; then
              # Package is not a compressed archive
              echo ""
            else
              echo "${default}"
            fi
          else
            echo "${archive_ext}"
          fi
      # yq pattern to match an asset
      PKG_ASSET_PATTERN:
        sh: |
          [ {{ quote .NAME }} == "unknown" ] && echo "Name was not provided" && exit 1
          pattern=$(yq --output-format json --unwrapScalar '.packages.{{.NAME}}.asset.pattern' {{.FILE}})
          if [ "${pattern}" == 'null' ]; then
            echo "Package asset.pattern '${pattern}' not defined in YAML" && exit 1
          else
            name={{.PKG_REPO_NAME}}
            os={{.PKG_OS}}
            arch={{.PKG_ARCH}}
            exe_ext={{exeExt}}
            archive_ext={{.PKG_ARCHIVE_EXT}}
            eval echo "$(echo "${pattern}")"
          fi
      # Regular expression to extract the Semantic versioning info from 'command version' or similar
      PKG_SEMVER_REGEX:
        sh: |
          [ {{ quote .NAME }} == "unknown" ] && echo "Name was not provided" && exit 1
          semver_regex=$(yq --output-format json --unwrapScalar '.packages.{{.NAME}}.semver.regex' {{.FILE}})
          if [ "${semver_regex}" == 'null' ]; then
            # Default is the standard v0.1.2
            echo 'v?[0-9]+\.([0-9]+\.?){1,}'
          else
            echo "${semver_regex}"
          fi
      # Command to check of the package is installed.
      PKG_STATUS_COMMAND:
        sh: |
          [ {{ quote .NAME }} == "unknown" ] && echo "Name was not provided" && exit 1
          status_command=$(yq --output-format json --unwrapScalar '.packages.{{.NAME}}.status.command' {{.FILE}})
          if [ "${status_command}" == 'null' ]; then
            echo "{{.NAME}} --version"
          else
            echo "${status_command}"
          fi
    cmds:
      - |
        echo 'NAME: {{.NAME}}'
        echo 'PKG_PROVIDER: {{.PKG_PROVIDER}}'
        echo 'PKG_REPO_NAME: {{.PKG_REPO_NAME}}'
        echo 'PKG_REPO_OWNER: {{.PKG_REPO_OWNER}}'
        echo 'PKG_ARCH: {{.PKG_ARCH}}'
        echo 'PKG_OS: {{.PKG_OS}}'
        echo 'PKG_ARCHIVE_DIR: {{.PKG_ARCHIVE_DIR}}'
        echo 'PKG_ARCHIVE_DIR_NAME: {{.PKG_ARCHIVE_DIR_NAME}}'
        echo 'PKG_ARCHIVE_FILE_NAME: {{.PKG_ARCHIVE_FILE_NAME}}'
        echo 'PKG_ARCHIVE_EXT: {{.PKG_ARCHIVE_EXT}}'
        echo 'PKG_ASSET_PATTERN: {{.PKG_ASSET_PATTERN}}'
        echo 'PKG_SEMVER_REGEX: {{.PKG_SEMVER_REGEX}}'
        echo 'PKG_STATUS_COMMAND: {{.PKG_STATUS_COMMAND}}'
      - task: :github:download
        vars: {
          REPO_NAME: '{{.PKG_REPO_NAME}}',
          REPO_OWNER: '{{.PKG_REPO_OWNER}}',
          REPO: '{{.PKG_REPO_OWNER}}/{{.PKG_REPO_NAME}}',
          PKG_ARCH: '{{.PKG_ARCH}}',
          PKG_OS: '{{.PKG_OS}}',
          FILE_NAME: '{{.NAME}}{{exeExt}}',
          PKG_ARCHIVE_DIR: '{{.PKG_ARCHIVE_DIR}}',
          PKG_ARCHIVE_DIR_NAME: '{{.PKG_ARCHIVE_DIR_NAME}}',
          PKG_ARCHIVE_FILE_NAME: '{{.PKG_ARCHIVE_FILE_NAME}}',
          PKG_ARCHIVE_EXT: '{{.PKG_ARCHIVE_EXT}}',
          PKG_ASSET_PATTERN: '{{.PKG_ASSET_PATTERN}}',
        }
    status:
      - '{{.PKG_STATUS_COMMAND}}'
